GDB:
	GNU Debugger is a debugger that is installed on nearly every linux system
	Run the program using the 'run' or 'r'
	'info functions' shows what functions are in the program
	Set a breakpoint using 'break *<id>' and either the name or memory address of the function
		Can also shorten the break to 'b'
		Can use 'continue' or 'c' to move to the next breakpoint
	Can use 'step' or 'next' to move through the program instruction by instruction
		Using step you will go into functions
		Next skips over functions
	Can inspect a memory addresss using 'x/i' followed by the memory address
		'x/x' to view it in hexadecimal
		Can view it as a string using 'x/s'
		Can put a number after the '/' to inspect more than one line
	Can use 'quit' to quit
		'q'

Debugging:


Integer Overflow:
	Can make an int store a number the max or min by overflowing or underflowing it
	Only way to mitigate is to make sure the result of any addition or subtraction falls within the allowed range of numbers and prevent it otherwise	

Buffer Overflow 1:
	Occurs when the user can input something into the program, there is only so much space reserved for input, and the programer doesn't check that the input will fit into the memory reserved and allows us to override adjacent memory addresses
	Can use a cyclic pattern to find where the specific bytes that a program needs to override is at
	Most systems use little endian format

Buffer Overflow 2:
	Code and data are the same
	Shell code is assembly code, but instead of labels we use the pure hexadecimal value
	Remember to inspect any shell code you find on the internet
	nop instructin means do nothing and move to the next instruction
	The memory address we see inside GDB will be slightly off the memory address we see outside GDB
	'nop' sled means no matter where you point EIP inside these instrucitons, execution will continue until it reaches our shellcode

Buffer Overflow 3:
	Always check the input length that a user has entered will fit into the buffer allocated for it
	Stack Canary is a value that sits before the return pointer in the stack
		-When the program's execution hits the return instruction, before the return pointer is loaded into EI{, the value of the stack canary is checked
		-Can usually be bypassed by finding out the value of the stack canary and overwriting it with the same value
	No Execution on Linux, or Data Execution Policy on Windows seperates areas of the stack into code and data, so you can't put shell code into memory and the tell the CPU to execute it
	Address Space Layout Randomisation (ASLR) is a protection that involves randomising the memory addresses that program gets loaded into on each run

Format Strings:
	If one is not used, the user can enter in a format specifier, then it will read data off of the stack
	Never use printf without a format string		
